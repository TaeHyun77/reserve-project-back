# 예매 시스템입니다.

테스트<br>
https://velog.io/@ayeah77/%EB%B6%84%EC%82%B0%EB%9D%BD-%EA%B5%AC%ED%98%84%EA%B3%BC-%ED%85%8C%EC%8A%A4%ED%8A%B8<br><br>

<p align="center">
  <img width="629" height="665" alt="Image" src="https://github.com/user-attachments/assets/ce06ebfe-b6f2-405f-a658-49ba16a6bdfd" />
</p>

<br>
<p>티켓 예약 로직에서 좌석 선택 → 예약 → 결제 , 포인트 리워드 지급의 일련의 과정에서 멱등적인 API와 동시성을 다뤄보고 해결해보고자 하는 프로젝트입니다.</p>
<p>멱등성( Idempotency )을 기반으로 예약 및 취소, 리워드 지급 로직에서 API의 중복 호출로 인한 오류를 방지했습니다.</p>
<p>동시성 문제가 발생할 수 있는 예약, 예약 취소, 리워드 지급 등의 핵심 로직에 Redis 분산 락 ( metex )을 도입하여 충돌을 방지했습니다.</p><br><br>

### 동시성 이슈

---

흔히 `따닥 이슈`라고 불리는 문제는, 사용자가 버튼을 빠르게 여러 번 클릭하면서 동일한 API 요청이 중복으로 발생하는 현상을 말합니다.

이러한 문제가 발생하면, 비즈니스 로직에 예외 처리를 해두었더라도 여러 요청이 예외 없이 모두 정상 처리되는 상황이 생길 수 있습니다.

이는 예약이 중복으로 처리되거나, 리워드가 중복 지급되는 등 심각한 문제의 원인이 됩니다.

이번 프로젝트에서 좌석 예약과 리워드 지급 로직을 다루고 있는 만큼 이에 대한 문제를 해결해보려고 합니다.<br><br>

**해결 방안**

동시성을 제어하는 여러 방법이 존재하지만, Redis를 활용한 분산 락 방식을 선택했습니다

그 이유는 Redis가 단일 서버 환경뿐만 아니라 분산 서버 환경에서도 락을 효과적으로 관리할 수 있고, 동시성 제어는 애플리케이션 레이어에서 처리하는 것이 유지보수에 더 효과적이라고 생각했으며,  컨트롤러나 서비스 단에서 빠르게 실패를 유도할 수 있어, 리소스 낭비를 최소화할 수 있을 것이라고 생각했기 때문입니다.

반면, DB 베타 락은 예외가 저장소 계층에서 발생하기 때문에, 불필요하게 로직이 모두 실행된 후에 실패를 감지하게 되는 문제가 있다고 보았습니다.<br><br>

**왜 DB락을 사용하지 않고 분산락을 사용하는지 ??? ( + 성능 고려 및 테스트 진행 )**<br><br>
⇒ 쿼리 실행까지 가야 락이 적용됨→ DB 부하 증가<br><br>
⇒ 트랜잭션 커밋 직전 또는 예외 발생 시점→ 로직이 모두 실행되고 나서야 실패<br><br>

⇒ 추후 분산락과 DB 낙관적, 비관적 락 방식의 성능 테스트를 진행해볼 예정입니다.

<br><br>

### 구현

Redis 분산 락은 Mutex Lock 방식을 사용하여 구현하였습니다.

Mutex Lock은 지정한 최대 대기 시간 내에 지속적으로 락을 획득할 때까지 확인하며 기다리고, 락을 획득하지 못하면 실패하도록 하여 리소스 낭비를 줄이고 빠르게 실패를 처리할 수 있도록 합니다.<br><br>

### 테스트

이번 좌석 예약 로직에는 멱등성을 보장하기 위한 API 처리와, 동시성 문제를 해결하기 위한 Redis 기반의 뮤텍스락 로직을 구현하였습니다.

이러한 기능들이 실제로 잘 작동하는지 확인하기 위해 JMeter를 활용한 테스트를 진행하려고 합니다.

- 요청이 정상적으로 락을 획득했는지
- 락이 적용된 상태에서 비즈니스 로직이 실행되었는지
- 멱등성 응답이 일관되게 반환되는지
<br>


`먼저, 멱등 키를 기반으로 만료되지 않은 요청 이력이 존재하는지 확인`

`만약 유효한 요청 이력이 존재하면, 해당 이력의 응답을 그대로 반환합니다.`

`이력이 없거나 만료되었다면, 외부 클라이언트를 호출하여 요청을 처리합니다.`

- `호출에 성공한 경우, 요청을 정상 수행하고 성공 이력을 저장합니다.`
- `호출에 실패한 경우, 실패 이력을 저장한 후 예외를 반환합니다.`<br><br>

`따라서, 성공한 동일 요청에 대해서는 그 응답을 그대로 재사용하고, 실패한 동일 요청에 대해서도 동일한 응답을 반환함으로써 멱등성이 유지됩니다.`<br><br>

### 테스트 결과

---

**성공적인 요청에 대한 API 테스트**

- 동시에 동일한 예약 요청이 두 번 온 경우
    
    ![](https://velog.velcdn.com/images/ayeah77/post/8822ac8a-71d3-4499-9bdf-131d6da6ca2b/image.png)
    첫 번째 요청에서는 예약이 정상적으로 처리되고, 두 번째 요청은 첫 번째 요청의 응답이 그대로 반환되는 것을 확인할 수 있습니다.<br><br>
    

- 동시에 예약 요청이 세 번 이상 온 경우
    
    ![](https://velog.velcdn.com/images/ayeah77/post/664ea5e3-70f3-41ac-b316-52005dddeebe/image.png)
    동시 요청 수를 늘려 동일한 예약 요청을 세 번 이상 동시에 수행해본 결과 역시, 첫 번째 요청을 제외한 나머지 요청은 첫 번째 요청의 응답을 그대로 반환하는 것을 볼 수 있습니다.<br><br>
    
    
**실패한 요청에 대한 API 테스트**

- 동시에 동일한 실패 예약 요청이 두 번 온 경우
	![](https://velog.velcdn.com/images/ayeah77/post/ece81e8f-372d-4bfd-b41e-6289ed653490/image.png)
<br><br>


- 동시에 동일한 실패 예약 요청이 세 번 이상 온 경우 ( 에러 발생 )

    **❌ 여러 개의 동시 요청 중 멱등 키 중복 저장 오류가 발생 ❌	**
    ![](https://velog.velcdn.com/images/ayeah77/post/2a0d522f-6e43-4b8c-a70b-29019baf5f62/image.png)
  <br><br>

    
    로직의 흐름이 `예약 로직 실행 → 멱등 키 저장` 순서로 이루어져 있고, Redis 분산 락이 예약 로직에만 적용되어 있기 때문<br><br>

  1. `요청 A가 들어옴 → Redis 락 획득`
  2. `A가 예약 로직 실행 중 ( doReserveSeats ) → 이 시점에는 다른 요청은 락을 못 잡음`
  3. `A의 예약 로직 종료 → 락 해제됨`
  4. `요청 B가 그 직후 들어옴 → 락 획득 성공 → 하지만 좌석은 이미 예약됨 상태`
  5. `요청 A는 이제 멱등성 키 저장 시도 → 성공`
  6. `요청 B도 실패 응답을 가지고 멱등성 키 저장 시도 → 중복 키 예외( Duplicate Key ) 발생`<br><br>

  이 문제를 해결하려면, 예약 로직과 멱등 키 저장 로직을 하나의 흐름으로 묶어 Redis 분산 락의 적용 범위 안에서 함께 처리해야 합니다.<br><br>
  
  ![](https://velog.velcdn.com/images/ayeah77/post/b0601518-2732-4e6a-b610-6bf5941509e5/image.png)
